{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from os import listdir\n",
    "from os.path import isfile, join\n",
    "\n",
    "import tensorflow as tf\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from sklearn.preprocessing import OneHotEncoder, scale\n",
    "import tensorflow as tf\n",
    "\n",
    "from ufcnn import compute_accuracy, construct_ufcnn, cross_entropy_loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def compute_market_prices(prices):\n",
    "    \"\"\"Compute market prices according to the trading competition recipe.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    prices : DataFrame\n",
    "        Data frame with market prices. Should include columns 'bid_price',\n",
    "        'bid_volume', 'aks_price', 'ask_volume'.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    prices : DataFrame\n",
    "        Same data frame, but with a column 'market_price' appended.\n",
    "    \"\"\"\n",
    "    denom = prices.bid_volume + prices.ask_volume\n",
    "    numer = (prices.bid_price * prices.ask_volume +\n",
    "             prices.ask_price * prices.bid_volume)\n",
    "    mask = denom == 0\n",
    "    denom[mask] = 2\n",
    "    numer[mask] = prices.bid_price[mask] + prices.ask_price[mask]\n",
    "    prices = prices.copy()\n",
    "    prices['market_price'] = numer / denom\n",
    "    return prices\n",
    "\n",
    "\n",
    "def find_optimal_strategy(prices, max_position=3, cost_per_trade=0.02):\n",
    "    \"\"\"Find optimal trading strategy.\n",
    "\n",
    "    A dynamic programming algorithm is used. Time complexity is \"number\n",
    "    of samples x number of maximum positions\".\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    prices : DataFrame\n",
    "        Data frame with market prices. Should include columns 'bid_price',\n",
    "        'aks_price', 'market_price'.\n",
    "    max_position : int\n",
    "        Maximum allowed number of positions in buying or selling.\n",
    "    cost_per_trade : float, default 0.02\n",
    "        Fee paid for every trade.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    actions : ndarray\n",
    "        Sequence of optimal actions: -1 for sell, 0 for hold, 1 for buy.\n",
    "        Length is the same as the number of columns in `prices`.\n",
    "    pnl : float\n",
    "        Profit per trading action.\n",
    "    \"\"\"\n",
    "    buy_price = prices.ask_price.values\n",
    "    sell_price = prices.bid_price.values\n",
    "\n",
    "    account = np.full((prices.shape[0] + 1, 2 * max_position + 3), -np.inf)\n",
    "    account[0, max_position + 1] = 0\n",
    "\n",
    "    actions = np.empty((prices.shape[0], 2 * max_position + 3), dtype=int)\n",
    "\n",
    "    for i in range(prices.shape[0]):\n",
    "        for j in range(1, account.shape[1] - 1):\n",
    "            buy = account[i, j - 1] - cost_per_trade - buy_price[i]\n",
    "            sell = account[i, j + 1] - cost_per_trade + sell_price[i]\n",
    "            hold = account[i, j]\n",
    "            if buy > sell and buy > hold:\n",
    "                account[i + 1, j] = buy\n",
    "                actions[i, j] = 1\n",
    "            elif sell > buy and sell > hold:\n",
    "                account[i + 1, j] = sell\n",
    "                actions[i, j] = -1\n",
    "            else:\n",
    "                account[i + 1, j] = hold\n",
    "                actions[i, j] = 0\n",
    "\n",
    "    pnl = account[-1, 1:-1] + (np.arange(-max_position, max_position + 1) *\n",
    "                               prices.market_price.iloc[-1])\n",
    "    j = np.argmax(pnl) + 1\n",
    "    optimal_sequence = []\n",
    "    for i in reversed(range(actions.shape[0])):\n",
    "        optimal_sequence.append(actions[i, j])\n",
    "        j -= actions[i, j]\n",
    "    optimal_sequence = np.array(list(reversed(optimal_sequence)))\n",
    "\n",
    "    return optimal_sequence, np.max(pnl) / optimal_sequence.size\n",
    "\n",
    "\n",
    "def simulate_trading(prices, actions, max_position=3, cost_per_trade=0.02):\n",
    "    \"\"\"Simulate trading according to given actions.\n",
    "\n",
    "    This is a literate translation of a pseudo code provided in [1]_.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    prices : DataFrame\n",
    "        Data frame with market prices. Should include columns 'bid_price',\n",
    "        'aks_price', 'market_price'.\n",
    "    actions : array_like\n",
    "        Sequence of actions: -1 for sell, 0 for hold, 1 for buy. Length is the\n",
    "        same as the number of columns in `prices`.\n",
    "    cost_per_trade : float, default 0.02\n",
    "        Fee paid for every trade.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    pnl : float\n",
    "        Profit per trading action.\n",
    "\n",
    "    References\n",
    "    ----------\n",
    "    .. [1] Roni Mittelman \"Time-series modeling with undecimated fully\n",
    "       convolutional neural networks\", http://arxiv.org/abs/1508.00317\n",
    "    \"\"\"\n",
    "    pnl = 0\n",
    "    position = 0\n",
    "    market_price = prices.market_price.values\n",
    "    buy_price = prices.ask_price.values\n",
    "    sell_price = prices.bid_price.values\n",
    "\n",
    "    for i in range(len(actions)):\n",
    "        if i > 0:\n",
    "            pnl += position * (market_price[i] - market_price[i - 1])\n",
    "\n",
    "        if actions[i] == 1 and position < max_position:\n",
    "            pnl -= cost_per_trade\n",
    "            pnl -= buy_price[i]\n",
    "            pnl += market_price[i]\n",
    "            position += 1\n",
    "        elif actions[i] == -1 and position > -max_position:\n",
    "            pnl -= cost_per_trade\n",
    "            pnl += sell_price[i]\n",
    "            pnl -= market_price[i]\n",
    "            position -= 1\n",
    "\n",
    "    return pnl / len(actions)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def prepare_prices(fname):\n",
    "    \"\"\"Read data and append market prices.\"\"\"\n",
    "    prices = pd.read_csv(fname, usecols=[2, 3, 4, 5],\n",
    "                         names=['bid_price', 'bid_volume', 'ask_price',\n",
    "                                'ask_volume'], delim_whitespace=True)\n",
    "    prices = compute_market_prices(prices)\n",
    "    return prices[['bid_price', 'ask_price', 'market_price']]\n",
    "\n",
    "\n",
    "def prepare_Xy(prices, max_position=3):\n",
    "    \"\"\"Prepare matrices for learning from prices data frame.\"\"\"\n",
    "    actions, pnl = find_optimal_strategy(prices, max_position=max_position)\n",
    "    X = prices[['bid_price', 'ask_price']].values\n",
    "    y = actions + 1\n",
    "\n",
    "    return X, y\n",
    "\n",
    "\n",
    "def compute_weights(y):\n",
    "    \"\"\"Compute weights inversly proportional to frequencies of labels.\n",
    "    \n",
    "    Parameters\n",
    "    ----------\n",
    "    y : ndarray, shape (batch_size, n_samples)\n",
    "        Labels.\n",
    "        \n",
    "    Returns\n",
    "    -------\n",
    "    weights : ndarray, shape (batch_size, n_samples)\n",
    "        Computed weights.\n",
    "    \"\"\"\n",
    "    weights = np.empty_like(y)\n",
    "    for j in range(y.shape[0]):    \n",
    "        encoder = OneHotEncoder(sparse=False)\n",
    "        ye = encoder.fit_transform(y[j].reshape((-1, 1)))\n",
    "        weights[j] = np.sum(ye / np.mean(ye, axis=0), axis=1)\n",
    "    \n",
    "    return weights"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Load data and prepare it for learning.\n",
    "# The last file is assumed to be used for testing, all other --- for training.\n",
    "\n",
    "path = \"./training_data_large\"\n",
    "files = [join(path, f) for f in listdir(path) if isfile(join(path, f))]\n",
    "files = sorted(files)\n",
    "\n",
    "X_train_all = []\n",
    "y_train_all = []\n",
    "for fname in files[:-1]:\n",
    "    prices = prepare_prices(fname)\n",
    "    X, y = prepare_Xy(prices, max_position=3)\n",
    "    \n",
    "    X = scale(X)\n",
    "    X_train_all.append(X[None, :, :])    \n",
    "    y_train_all.append(y[None, :])\n",
    "\n",
    "\n",
    "test_prices = prepare_prices(files[-1])\n",
    "X, y = prepare_Xy(test_prices, max_position=3)\n",
    "X = scale(X)\n",
    "X_test = X[None, :, :]\n",
    "y_test = y[None, :]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Define network architecture.\n",
    "\n",
    "x, y_hat, *_ = construct_ufcnn(n_inputs=2, n_outputs=3, n_levels=4, n_filters=30)\n",
    "labels = tf.placeholder(tf.int32, shape=[None, None])\n",
    "sample_weights = tf.placeholder(tf.float32, shape=[None, None])\n",
    "\n",
    "loss = cross_entropy_loss(y_hat, labels, sample_weights=sample_weights, sparse=True)\n",
    "\n",
    "optimizer = tf.train.RMSPropOptimizer(1e-3)\n",
    "train_step = optimizer.minimize(loss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  Epoch      Loss      PNL     Buy acc. Sell acc. \n",
      "    0        2.59    2.95e-04    0.00      0.52   \n",
      "    1        2.30    2.95e-04    0.00      0.47   \n",
      "    2        2.12    2.95e-04    0.00      0.45   \n",
      "    3        1.99    2.76e-04    0.00      0.40   \n",
      "    4        1.88   -4.89e-03    0.01      0.37   \n",
      "    5        1.84    1.21e-03    0.20      0.27   \n",
      "    6        1.84    1.52e-03    0.21      0.27   \n",
      "    7        1.83   -6.56e-03    0.18      0.29   \n",
      "    8        1.76    1.15e-03    0.22      0.23   \n",
      "    9        1.72    1.27e-03    0.21      0.23   \n",
      "    10       1.69    3.01e-04    0.20      0.24   \n",
      "    11       1.65   -1.86e-03    0.20      0.23   \n",
      "    12       1.62   -2.49e-03    0.20      0.22   \n",
      "    13       1.62   -2.28e-02    0.09      0.27   \n",
      "    14       1.56   -1.46e-02    0.13      0.25   \n",
      "    15       1.53    1.03e-03    0.20      0.21   \n",
      "    16       1.48    1.23e-03    0.23      0.19   \n",
      "    17       1.44   -5.85e-03    0.00      0.37   \n",
      "    18       1.41   -1.30e-03    0.20      0.19   \n",
      "    19       1.38   -4.16e-03    0.20      0.22   \n"
     ]
    }
   ],
   "source": [
    "# Training loop.\n",
    "# Works only with batches of size 1.\n",
    "\n",
    "n_epochs = 20\n",
    "report_every = 1\n",
    "\n",
    "print(\"{:^10}{:^10}{:^10}{:^10}{:^10}\".format(\"Epoch\", \"Loss\", \"PNL\", \"Buy acc.\", \"Sell acc.\"))\n",
    "\n",
    "session = tf.Session()\n",
    "session.run(tf.initialize_all_variables())\n",
    "for epoch in range(n_epochs):\n",
    "    if epoch % report_every == 0:\n",
    "        weights = compute_weights(y_test)\n",
    "        \n",
    "        ce = session.run(loss, feed_dict={x: X_test, labels: y_test,\n",
    "                                          sample_weights: weights})\n",
    "        \n",
    "        prediction = session.run(y_hat, feed_dict={x: X_test})\n",
    "        actions = np.squeeze(prediction)\n",
    "        actions = np.argmax(actions, axis=-1)\n",
    "        \n",
    "        buy_acc = np.sum((actions == 2) & (y_test == 2)) / np.sum(y_test == 2)\n",
    "        sell_acc = np.sum((actions == 0) & (y_test == 0)) / np.sum(y_test == 0)\n",
    "        \n",
    "        actions -= 1\n",
    "        pnl = simulate_trading(test_prices, actions, max_position=3)\n",
    "\n",
    "        print(\"{:^10}{:^10.2f}{:^10.2e}{:^10.2f}{:^10.2f}\"\n",
    "              .format(epoch, ce, pnl, buy_acc, sell_acc))\n",
    "    \n",
    "    X_train = X_train_all[epoch % len(X_train_all)]\n",
    "    y_train = y_train_all[epoch % len(y_train_all)]\n",
    "    weights = compute_weights(y_train)\n",
    "    \n",
    "    session.run(train_step, feed_dict={x: X_train, labels: y_train,\n",
    "                                       sample_weights: weights})\n",
    "session.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
